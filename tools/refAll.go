package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
)

// The refAll tool writes a go source file to stdout that contains a reference to every public function,
// struct, and value in a given directory. This is useful for determining semantic versions of SDKs
// generated by swagger codegen. diffs of a new reference file against the previous one determine
// which semantic versioning component to bump: removed or changed references indicate a MAJOR
// version increment, added lines indicate a MINOR version increment, and no difference indicates
// a PATCH version increment.
//
// This tool could probably be generalized to work on any golang package source that implements
// a semantically-versioned interface: it currently only generates references to interface
// elements that appear in swagger codegen SDKs but it could handle the entire go language.
//
// This tool could also potentially be modified to generate a full test client to exercise the
// SDK - instead of plain references, we would generate SDK calls.

func main() {
	// debug := flag.Bool("debug", false, "Print debug information to stderr")
	dirPath := os.Args[1]
	fset := token.NewFileSet()

	pkgs, err := parser.ParseDir(fset, dirPath, nil, 0)
	if err != nil {
		fmt.Println(err)
		return
	}

	for pkgName, pkg := range pkgs {
		fmt.Println("package", pkgName)
		pr := newPackageRefs(pkgName, fset)
		ast.PackageExports(pkg)
		for fileName, file := range pkg.Files {
			fmt.Println("  fileName", fileName)
			for _, decl := range file.Decls {
				switch declVal := decl.(type) {
				case *ast.FuncDecl:
					fmt.Printf("    FuncDecl: %+v\n", declVal)
					pr.addFuncDecl(declVal)
				case *ast.GenDecl:
					fmt.Printf("    GenDecl: %+v\n", declVal)
					for _, spec := range declVal.Specs {
						switch specVal := spec.(type) {
						case *ast.ImportSpec:
							fmt.Printf("      ImportSpec: %+v\n", specVal)
						case *ast.ValueSpec:
							fmt.Printf("      ValueSpec: %+v\n", specVal)
							pr.addValueSpec(specVal)
							for _, v := range specVal.Values {
								fmt.Printf("        Value: %+v\n", v)
							}
						case *ast.TypeSpec:
							fmt.Printf("      TypeSpec: %+v\n", specVal)
							pr.addTypeSpec(specVal)
							switch typeVal := specVal.Type.(type) {
							case *ast.StructType:
								fmt.Printf("        Struct: %+v\n", typeVal)
								for _, field := range typeVal.Fields.List {
									fmt.Printf("          Field: %+v\n", field)
								}
							default:
								fmt.Printf("        default: %+v\n", typeVal)
							}
						default:
							fmt.Printf("      default: %+v\n", specVal)
						}
					}
				default:
					fmt.Printf("   default: %+v\n", declVal)
				}
			}
		}
		pr.write()
	}
}

type packageRefs struct {
	pkgName    string
	fset       *token.FileSet
	funcDecls  []*ast.FuncDecl
	typeSpecs  []*ast.TypeSpec
	valueSpecs []*ast.ValueSpec
}

func newPackageRefs(pkgName string, fset *token.FileSet) *packageRefs {
	pr := new(packageRefs)
	pr.pkgName = pkgName
	pr.fset = fset

	return pr
}

func (pr *packageRefs) addFuncDecl(funcDecl *ast.FuncDecl) {
	pr.funcDecls = append(pr.funcDecls, funcDecl)
}

func (pr *packageRefs) addValueSpec(valueSpec *ast.ValueSpec) {
	pr.valueSpecs = append(pr.valueSpecs, valueSpec)
}

func (pr *packageRefs) addTypeSpec(typeSpec *ast.TypeSpec) {
	pr.typeSpecs = append(pr.typeSpecs, typeSpec)
}

func (pr *packageRefs) write() {
	fmt.Printf("package main\n\n")
	fmt.Printf("import %s\n", pr.pkgName)

	// TODO sort remaining arrays
	fmt.Printf("\n// Functions\n")
	for _, funcDecl := range pr.funcDecls {
		fmt.Printf("_ = %s.%s\n", pr.pkgName, funcDecl.Name)
	}

	fmt.Printf("\n// Structs\n")
	for _, typeSpec := range pr.typeSpecs {
		structType, ok := typeSpec.Type.(*ast.StructType)
		if ok {
			fmt.Printf("\nvar _  %s.%s\n", pr.pkgName, typeSpec.Name)
			fmt.Printf("// Fields for %s\n", typeSpec.Name)
			for _, field := range structType.Fields.List {
				if len(field.Names) == 0 {
					// (I think) no Names means this is an embedded anonymous field, the type name is
					// the implicit field name. https://golang.org/pkg/go/ast/#Field
					fmt.Printf("var _ %s = new(%s.%s).%s // XXX Case 0\n", nodeString(field.Type, pr.fset), pr.pkgName, typeSpec.Name, field.Type)
				} else {
					for _, name := range field.Names {
						// Normal named field
						fmt.Printf("var _ %s = new(%s.%s).%s\n", nodeString(field.Type, pr.fset), pr.pkgName, typeSpec.Name, name)
					}
				}
			}
		}
	}

	fmt.Printf("\n// Values\n")
	for _, valueSpec := range pr.valueSpecs {
		for _, name := range valueSpec.Names {
			// BUG(bb): We skip values with inferred type. They don't appear in the SDK code that changes and
			// I don't know how to find their type. Probably look at https://github.com/golang/example/tree/master/gotypes
			// for clues.
			if valueSpec.Type == nil {
				log.Printf("Skipping value %s with no Type\n", name)
			} else {
				fmt.Printf("var _ %s = %s.%s\n", valueSpec.Type, pr.pkgName, name)
			}
		}
	}
}

// nodeString formats a syntax tree in the style of gofmt.
func nodeString(n ast.Node, fset *token.FileSet) string {
	var buf bytes.Buffer
	err := format.Node(&buf, fset, n)
	if err != nil {
		log.Fatal(err)
	}
	return buf.String()
}
