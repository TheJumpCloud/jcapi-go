package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"reflect"
)

// The refAll tool writes a go source file to stdout that contains a reference to every public function,
// struct, and value in a given directory. This is useful for determining semantic versions of SDKs
// generated by swagger codegen. diffs of a new reference file against the previous one determine
// which semantic versioning component to bump: removed or changed references indicate a MAJOR
// version increment, added lines indicate a MINOR version increment, and no difference indicates
// a PATCH version increment.
//
// This tool could probably be generalized to work on any golang package source that implements
// a semantically-versioned interface: it currently only generates references to interface
// elements that appear in swagger codegen SDKs but it could handle the entire go language.
//
// This tool could also potentially be modified to generate a full test client to exercise the
// SDK - instead of plain references, we would generate SDK calls.

func main() {
	// debug := flag.Bool("debug", false, "Print debug information to stderr")
	dirPath := os.Args[1]
	fset := token.NewFileSet()

	pkgs, err := parser.ParseDir(fset, dirPath, nil, 0)
	if err != nil {
		fmt.Println(err)
		return
	}

	for pkgName, pkg := range pkgs {
		fmt.Println("package", pkgName)
		pr := newPackageRefs(pkgName)
		ast.PackageExports(pkg)
		for fileName, file := range pkg.Files {
			fmt.Println("  fileName", fileName)
			for _, decl := range file.Decls {
				switch declVal := decl.(type) {
				case *ast.FuncDecl:
					fmt.Printf("    FuncDecl: %+v\n", declVal)
					pr.addFuncDecl(declVal)
				case *ast.GenDecl:
					fmt.Printf("    GenDecl: %+v\n", declVal)
					for _, spec := range declVal.Specs {
						switch specVal := spec.(type) {
						case *ast.ImportSpec:
							fmt.Printf("      ImportSpec: %+v\n", specVal)
						case *ast.ValueSpec:
							fmt.Printf("      ValueSpec: %+v\n", specVal)
							pr.addValueSpec(specVal)
						case *ast.TypeSpec:
							fmt.Printf("      TypeSpec: %+v\n", specVal)
							pr.addTypeSpec(specVal)
							switch typeVal := specVal.Type.(type) {
							case *ast.StructType:
								fmt.Printf("        Struct: %+v\n", typeVal)
								for _, field := range typeVal.Fields.List {
									fmt.Printf("          Field: %+v\n", field)
								}
							default:
								fmt.Printf("        default: %+v\n", typeVal)
							}
						default:
							fmt.Printf("      default: %+v\n", specVal)
						}
					}
				default:
					fmt.Printf("   default: %+v\n", declVal)
				}
			}
		}
		pr.write()
	}
}

type packageRefs struct {
	pkgName    string
	funcDecls  []*ast.FuncDecl
	typeSpecs  []*ast.TypeSpec
	valueSpecs []*ast.ValueSpec
}

func newPackageRefs(pkgName string) *packageRefs {
	pr := new(packageRefs)
	pr.pkgName = pkgName

	return pr
}

func (pr *packageRefs) addFuncDecl(funcDecl *ast.FuncDecl) {
	pr.funcDecls = append(pr.funcDecls, funcDecl)
}

func (pr *packageRefs) addValueSpec(valueSpec *ast.ValueSpec) {
	pr.valueSpecs = append(pr.valueSpecs, valueSpec)
}

func (pr *packageRefs) addTypeSpec(typeSpec *ast.TypeSpec) {
	pr.typeSpecs = append(pr.typeSpecs, typeSpec)
}

func (pr *packageRefs) write() {
	fmt.Printf("package main\n\n")
	fmt.Printf("import %s\n", pr.pkgName)

	// TODO sort remaining arrays
	fmt.Printf("\n// Functions\n")
	for _, funcDecl := range pr.funcDecls {
		fmt.Printf("_ = %s.%s\n", pr.pkgName, funcDecl.Name)
	}

	fmt.Printf("\n// Structs\n")
	for _, typeSpec := range pr.typeSpecs {
		structType, ok := typeSpec.Type.(*ast.StructType)
		if ok {
			fmt.Printf("var _  %s.%s\n", pr.pkgName, typeSpec.Name)
			fmt.Printf("\n// Fields for %s\n", typeSpec.Name)
			for _, field := range structType.Fields.List {
				fmt.Printf("// typeof field type %s\n", reflect.TypeOf(field.Type))
				switch len(field.Names) {
				case 0:
					// (I think) no Names means this is an embedded anonymous field, the type name is
					// the implicit field name. https://golang.org/pkg/go/ast/#Field
					fmt.Printf("var _ *%s = new(%s.%s).%s // XXX Case 0\n", field.Type, pr.pkgName, typeSpec.Name, field.Type)
				case 1:
					// Normal field with a name
					fmt.Printf("var _ *%s = new(%s.%s).%s\n", field.Type, pr.pkgName, typeSpec.Name, field.Names[0])
				default:
					fmt.Fprintf(os.Stderr, "Skipping %+v (multiple names)", field)
				}
			}
		}
	}

	fmt.Printf("\n// Values\n")
	for _, valueSpec := range pr.valueSpecs {
		fmt.Printf("var _ %s = %s.%s\n", valueSpec.Type, valueSpec.Names[0])
		if len(valueSpec.Names) != 1 {
			panic(fmt.Sprintf("I only understand fields with one Name: %+v %d", valueSpec, len(valueSpec.Names)))
		}
	}
}
