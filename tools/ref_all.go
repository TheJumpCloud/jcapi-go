package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"regexp"
	"sort"
	"strings"
)

// The ref_all tool writes a go source file to stdout that contains a reference to every public function,
// struct, struct field, and value in a given directory. This is useful for determining semantic versions
// of SDKs generated by swagger codegen. diffs of a new reference file against the previous one determine
// which semantic versioning component to bump: removed or changed references indicate a MAJOR
// version increment, added lines indicate a MINOR version increment, and no difference indicates
// a PATCH version increment.
//
// Usage example:
// $ go run tools/ref_all.go -imports "fmt,net/http,time" -pkgBase github.com/TheJumpCloud/jcapi-go v1 > ref_v1_1_35_0.go
//
// This tool could probably be generalized to work on any golang package source that implements
// a semantically-versioned interface: it currently only generates references to interface
// elements that appear in swagger codegen SDKs but it could handle the entire go language.
//
// This tool could also potentially be modified to generate a full test client to exercise the
// SDK - instead of plain references, we would generate SDK calls.

type config struct {
	pkgBase    string
	importPkgs []string
}

var cfg config

func main() {
	// TODO(bb) both of these cmd-line args could probably be gleaned from the ast
	flag.StringVar(&cfg.pkgBase, "pkgBase", "", "Base path for packages being referenced (e.g. \"github.com/TheJumpCloud/jcapi-go/v2\")")
	imports := flag.String("imports", "", "Comma-separated list of packages to import")
	flag.Parse()
	if *imports != "" {
		cfg.importPkgs = strings.Split(*imports, ",")
	}
	dirPath := flag.Arg(0)
	fset := token.NewFileSet()

	pkgs, err := parser.ParseDir(fset, dirPath, nil, 0)
	if err != nil {
		log.Println(err)
		return
	}

	for pkgName, pkg := range pkgs {
		pr := newPackageRefs(pkgName, fset)
		ast.PackageExports(pkg)
		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				switch declVal := decl.(type) {
				case *ast.FuncDecl:
					pr.addFuncDecl(declVal)
				case *ast.GenDecl:
					for _, spec := range declVal.Specs {
						switch specVal := spec.(type) {
						case *ast.ValueSpec:
							pr.addValueSpec(specVal)
						case *ast.TypeSpec:
							pr.addTypeSpec(specVal)
						}
					}
				}
			}
		}
		pr.write()
	}
}

type packageRefs struct {
	pkgName    string
	fset       *token.FileSet
	funcDecls  []*ast.FuncDecl
	typeSpecs  []*ast.TypeSpec
	valueSpecs []*ast.ValueSpec
}

func newPackageRefs(pkgName string, fset *token.FileSet) *packageRefs {
	pr := new(packageRefs)
	pr.pkgName = pkgName
	pr.fset = fset

	return pr
}

func (pr *packageRefs) addFuncDecl(funcDecl *ast.FuncDecl) {
	pr.funcDecls = append(pr.funcDecls, funcDecl)
}

func (pr *packageRefs) addValueSpec(valueSpec *ast.ValueSpec) {
	pr.valueSpecs = append(pr.valueSpecs, valueSpec)
}

func (pr *packageRefs) addTypeSpec(typeSpec *ast.TypeSpec) {
	pr.typeSpecs = append(pr.typeSpecs, typeSpec)
}

func (pr *packageRefs) write() {
	pr.writeHeader()
	pr.writeFunctions()
	pr.writeStructs()
	pr.writeValues()
	pr.writeFooter()
}

func (pr *packageRefs) writeHeader() {
	fmt.Printf("package main\n\n")
	fmt.Printf("import (\n")
	if cfg.pkgBase != "" {
		fmt.Printf("    %s \"%s/%s\"\n", pr.pkgName, cfg.pkgBase, pr.pkgName)
	} else {
		fmt.Printf("    \"%s\"\n", pr.pkgName)
	}
	for _, imp := range cfg.importPkgs {
		fmt.Printf("    \"%s\"\n", imp)
	}
	fmt.Printf(")\n\n")
	fmt.Printf("func main() {\n")
}

func (pr *packageRefs) writeFunctions() {
	fmt.Printf("\n    // Functions\n")
	sort.Slice(pr.funcDecls, func(i, j int) bool {
		return strings.Compare(pr.funcDecls[i].Name.Name, pr.funcDecls[j].Name.Name) < 0
	})
	for _, funcDecl := range pr.funcDecls {
		if funcDecl.Recv == nil {
			fmt.Printf("    _ = %s.%s\n", pr.pkgName, funcDecl.Name)
		} else {
			// For methods, create a bound reference for each receiver type
			for _, field := range funcDecl.Recv.List {
				typeAsName := baseTypeName(nodeString(field.Type, pr.fset, ""))
				if ast.IsExported(typeAsName) {
					fmt.Printf("    _ = new(%s.%s).%s\n", pr.pkgName, baseTypeName(typeAsName), funcDecl.Name)
				}
			}
		}
	}
}

func (pr *packageRefs) writeStructs() {
	fmt.Printf("\n    // Structs\n")
	sort.Slice(pr.typeSpecs, func(i, j int) bool {
		return strings.Compare(pr.typeSpecs[i].Name.Name, pr.typeSpecs[j].Name.Name) < 0
	})
	for _, typeSpec := range pr.typeSpecs {
		structType, ok := typeSpec.Type.(*ast.StructType)
		if ok {
			fmt.Printf("\n    var _  %s.%s\n", pr.pkgName, typeSpec.Name)
			fmt.Printf("    // Fields for %s\n", typeSpec.Name)
			for _, field := range structType.Fields.List {
				if len(field.Names) == 0 {
					// (I think) no Names means this is an embedded anonymous field, the base type name is
					// the implicit field name. https://golang.org/pkg/go/ast/#Field
					typeAsName := nodeString(field.Type, pr.fset, pr.pkgName)
					fmt.Printf("    var _ %s = new(%s.%s).%s\n", typeAsName, pr.pkgName, typeSpec.Name, baseTypeName(typeAsName))
				} else {
					for _, name := range field.Names {
						// Normal named field
						fmt.Printf("    var _ %s = new(%s.%s).%s\n", nodeString(field.Type, pr.fset, pr.pkgName), pr.pkgName, typeSpec.Name, name)
					}
				}
			}
		}
	}
}

func (pr *packageRefs) writeValues() {
	fmt.Printf("\n    // Values\n")
	sort.Slice(pr.valueSpecs, func(i, j int) bool {
		vi := pr.valueSpecs[i]
		vj := pr.valueSpecs[j]
		return len(vi.Names) == 0 || len(vj.Names) == 0 || strings.Compare(pr.valueSpecs[i].Names[0].Name, pr.valueSpecs[j].Names[0].Name) < 0
	})
	for _, valueSpec := range pr.valueSpecs {
		for _, name := range valueSpec.Names {
			// BUG(bb): We skip values with inferred type. They don't appear in the SDK code that changes and
			// I don't know how to find their type. Look at https://github.com/golang/example/tree/master/gotypes
			// for clues.
			if valueSpec.Type == nil {
				log.Printf("Skipping value %s with no Type\n", name)
			} else {
				fmt.Printf("    var _ %s.%s = %s.%s\n", pr.pkgName, valueSpec.Type, pr.pkgName, name)
			}
		}
	}
}

func (pr *packageRefs) writeFooter() {
	fmt.Printf("\n    fmt.Println(\"Package %s\")\n", pr.pkgName)
	fmt.Printf("}\n")
}

// nodeString prints a syntax tree node
func nodeString(n ast.Node, fset *token.FileSet, pkgName string) string {
	var buf bytes.Buffer
	err := printer.Fprint(&buf, fset, n)
	if err != nil {
		log.Fatal(err)
	}
	// Hack(bb): format.Node does not include the package name in exported package names, insert it
	s := buf.String()
	if pkgName != "" && !strings.Contains(s, ".") {
		base := baseTypeName(s)
		if ast.IsExported(base) {
			s = strings.Replace(s, base, pkgName+"."+base, 1)
		}
	}
	return s
}

var reBaseTypeName *regexp.Regexp

// baseTypeName returns the type name with *, selector parents, etc removed
func baseTypeName(t string) string {
	if reBaseTypeName == nil {
		var err error
		reBaseTypeName, err = regexp.Compile("[a-zA-Z0-9_]+$")
		if err != nil {
			log.Fatal(err)
		}
	}
	return reBaseTypeName.FindString(t)
}
